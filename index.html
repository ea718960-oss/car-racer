<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Highway Racer ¬∑ Emmanuel Boost</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        body {
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(45deg, #0b1a2e, #1a2f3f);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            padding: 16px;
        }
        .game-container {
            background: #1e3b4f;
            border-radius: 40px;
            padding: 24px;
            box-shadow: 0 20px 30px rgba(0,0,0,0.6), inset 0 0 8px #5f9ea0;
            border: 2px solid #ffb347;
        }
        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 24px;
            background: #2d4d5e;
            box-shadow: inset 0 0 0 3px #a5661e, 0 10px 15px -5px black;
            cursor: none;
            touch-action: none;
        }
        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 8px 8px 8px;
            color: #ffd966;
            font-weight: bold;
            text-shadow: 2px 2px 0 #1e3b4f;
        }
        .score-box {
            background: #0f2a36;
            padding: 8px 24px;
            border-radius: 60px;
            font-size: 1.8rem;
            letter-spacing: 2px;
            border: 2px solid #f3a446;
            box-shadow: inset 0 -2px 0 #a5661e;
            color: #ffe484;
            font-family: monospace;
        }
        .highscore-box {
            background: #0f2a36;
            padding: 8px 24px;
            border-radius: 60px;
            font-size: 1.4rem;
            border: 2px solid #f3a446;
            color: #ffe484;
            font-family: monospace;
        }
        button {
            background: #f3a446;
            border: none;
            color: #1a2f3f;
            font-size: 1.3rem;
            font-weight: 800;
            padding: 8px 28px;
            border-radius: 40px;
            letter-spacing: 1px;
            box-shadow: 0 6px 0 #9b601d, 0 8px 12px black;
            cursor: pointer;
            transition: all 0.07s;
            border: 1px solid #ffcd94;
        }
        button:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #9b601d, 0 5px 10px black;
        }
        .controls {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 16px;
            color: #cfe2e0;
            font-size: 1rem;
            background: #15303e;
            padding: 8px 16px;
            border-radius: 60px;
            border: 1px solid #ffb347;
        }
        .controls i {
            font-style: normal;
            background: #f3a446;
            color: #0a1c26;
            padding: 4px 12px;
            border-radius: 30px;
            font-weight: 700;
            margin: 0 4px;
        }
        .footer-note {
            text-align: center;
            margin-top: 12px;
            color: #b0d4d0;
        }
        .footer-note span {
            color: #ffb347;
        }
        .powerup-status {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 8px;
            font-size: 1rem;
            background: #15303e;
            padding: 6px 16px;
            border-radius: 40px;
            border: 1px solid #f3a446;
            color: #ffd966;
        }
        .powerup-status i {
            font-style: normal;
            background: #2a4b5c;
            padding: 2px 12px;
            border-radius: 20px;
            margin-left: 8px;
            color: white;
        }
        .top-scores {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 8px;
        }
    </style>
</head>
<body>
<div class="game-container">
    <canvas id="gameCanvas" width="500" height="600"></canvas>

    <div class="info-panel">
        <span class="score-box" id="scoreDisplay">0</span>
        <span class="highscore-box" id="highScoreDisplay">üèÜ 0</span>
        <button id="restartBtn">‚Üª DRIVE AGAIN</button>
    </div>

    <div class="controls">
        <span><i>‚Üê‚Üí</i> move left/right</span>
        <span><i>‚Üë‚Üì</i> move up/down</span>
        <span>‚ö° avoid cars</span>
    </div>

    <!-- power-up indicators -->
    <div class="powerup-status" id="powerupStatus">
        <span>‚ö° BOOST <i id="boostTimer">OFF</i></span>
        <span>üõ°Ô∏è EMMANUEL <i id="emmanuelTimer">OFF</i></span>
    </div>

    <div class="footer-note">
        üöó <span>HUMAN NEED ¬∑ BOOST 65s ¬∑ EMMANUEL 75s ¬∑ DURATION 50s</span> üöó
    </div>
</div>

<script>
    (function() {
        // ---------- CANVAS ----------
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreSpan = document.getElementById('scoreDisplay');
        const highScoreSpan = document.getElementById('highScoreDisplay');
        const boostTimerSpan = document.getElementById('boostTimer');
        const emmanuelTimerSpan = document.getElementById('emmanuelTimer');

        // ---------- FIXED DIMENSIONS ----------
        const ROAD_WIDTH = canvas.width;
        const CAR_WIDTH = 50;
        const CAR_HEIGHT = 80;
        const OBSTACLE_WIDTH = 48;
        const OBSTACLE_HEIGHT = 82;
        const POWERUP_SIZE = 40;

        // Player car with vertical movement bounds
        const MIN_Y = 20;
        const MAX_Y = canvas.height - CAR_HEIGHT - 20;

        const player = {
            x: (canvas.width / 2) - (CAR_WIDTH / 2),
            y: canvas.height - CAR_HEIGHT - 20, // start near bottom
            width: CAR_WIDTH,
            height: CAR_HEIGHT,
            baseSpeed: 7,
            speed: 7,
        };

        // Obstacles & power-ups
        let obstacles = [];
        let powerUps = [];

        // Game state
        let gameActive = false;
        let frameId = null;
        let score = 0;
        let highScore = 0;

        // Load high score from localStorage
        try {
            const saved = localStorage.getItem('highwayRacerHighScore');
            if (saved) highScore = parseInt(saved, 10) || 0;
        } catch (e) { /* ignore */ }
        highScoreSpan.textContent = 'üèÜ ' + highScore;

        let baseSpeed = 3.5;
        let speedMultiplier = 1.0;
        let framesSinceLastObstacle = 0;
        const OBSTACLE_GAP_MIN = 45;
        const OBSTACLE_GAP_MAX = 70;
        let nextObstacleFrame = 45;

        // Power-up timers (time-based spawn)
        let lastBoostSpawn = 0;
        const BOOST_SPAWN_INTERVAL = 65000; // 65 seconds
        let lastEmmanuelSpawn = 0;
        const EMMANUEL_SPAWN_INTERVAL = 75000; // 75 seconds

        // Effect flags and timers - now lasting 50 seconds (3000 frames at 60fps)
        let boostActive = false;
        let boostFramesLeft = 0;
        const BOOST_DURATION_FRAMES = 3000; // 50 seconds

        let invisibleActive = false;
        let invisibleFramesLeft = 0;
        const INVISIBLE_DURATION_FRAMES = 3000; // 50 seconds

        // Keyboard: now with up/down
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            ArrowUp: false,
            ArrowDown: false
        };

        // ---------- HELPER FUNCTIONS ----------
        function resetGame() {
            gameActive = true;
            obstacles = [];
            powerUps = [];
            player.x = (canvas.width / 2) - (CAR_WIDTH / 2);
            player.y = canvas.height - CAR_HEIGHT - 20; // reset to bottom
            player.speed = player.baseSpeed;
            score = 0;
            baseSpeed = 3.5;
            speedMultiplier = 1.0;
            framesSinceLastObstacle = 0;
            nextObstacleFrame = randomSpawnDelay();

            const now = performance.now();
            lastBoostSpawn = now;
            lastEmmanuelSpawn = now;

            boostActive = false;
            boostFramesLeft = 0;
            invisibleActive = false;
            invisibleFramesLeft = 0;

            updateScore();
            updatePowerupDisplay();
        }

        function randomSpawnDelay() {
            return Math.floor(Math.random() * (OBSTACLE_GAP_MAX - OBSTACLE_GAP_MIN + 1) + OBSTACLE_GAP_MIN);
        }

        function updateScore() {
            scoreSpan.textContent = Math.floor(score);
            // Update high score
            if (score > highScore) {
                highScore = score;
                highScoreSpan.textContent = 'üèÜ ' + Math.floor(highScore);
                // Save to localStorage
                try {
                    localStorage.setItem('highwayRacerHighScore', Math.floor(highScore));
                } catch (e) {}
            }
        }

        function updatePowerupDisplay() {
            if (boostActive) {
                boostTimerSpan.textContent = (boostFramesLeft / 60).toFixed(1) + 's';
            } else {
                boostTimerSpan.textContent = 'OFF';
            }
            if (invisibleActive) {
                emmanuelTimerSpan.textContent = (invisibleFramesLeft / 60).toFixed(1) + 's';
            } else {
                emmanuelTimerSpan.textContent = 'OFF';
            }
        }

        function spawnObstacle() {
            const lane = Math.floor(Math.random() * 3);
            let laneX;
            if (lane === 0) laneX = 40;
            else if (lane === 1) laneX = canvas.width/2 - OBSTACLE_WIDTH/2;
            else laneX = canvas.width - OBSTACLE_WIDTH - 40;

            obstacles.push({
                x: laneX,
                y: -OBSTACLE_HEIGHT - Math.random() * 30,
                width: OBSTACLE_WIDTH,
                height: OBSTACLE_HEIGHT,
            });
        }

        function spawnPowerUp(type) {
            const lane = Math.floor(Math.random() * 3);
            let laneX;
            if (lane === 0) laneX = 40 + 10;
            else if (lane === 1) laneX = canvas.width/2 - POWERUP_SIZE/2;
            else laneX = canvas.width - POWERUP_SIZE - 40 - 10;

            powerUps.push({
                x: laneX,
                y: -POWERUP_SIZE - Math.random() * 20,
                width: POWERUP_SIZE,
                height: POWERUP_SIZE,
                type: type,
            });
        }

        function rectCollide(r1, r2) {
            return !(r2.x >= r1.x + r1.width ||
                r2.x + r2.width <= r1.x ||
                r2.y >= r1.y + r1.height ||
                r2.y + r2.height <= r1.y);
        }

        function gameOver() {
            gameActive = false;
            if (frameId) {
                cancelAnimationFrame(frameId);
                frameId = null;
            }
        }

        // Move player with all four directions
        function movePlayer() {
            if (!gameActive) return;

            // Horizontal
            if (keys.ArrowLeft && player.x > 20) {
                player.x -= player.speed;
            }
            if (keys.ArrowRight && player.x < canvas.width - player.width - 20) {
                player.x += player.speed;
            }
            // Vertical
            if (keys.ArrowUp && player.y > MIN_Y) {
                player.y -= player.speed;
            }
            if (keys.ArrowDown && player.y < MAX_Y) {
                player.y += player.speed;
            }

            // Hard boundaries
            if (player.x < 5) player.x = 5;
            if (player.x + player.width > canvas.width - 5) player.x = canvas.width - player.width - 5;
            if (player.y < MIN_Y) player.y = MIN_Y;
            if (player.y > MAX_Y) player.y = MAX_Y;
        }

        // Update game logic
        function updateGame(now) {
            if (!gameActive) return;

            speedMultiplier = 1.0 + Math.floor(score / 200) * 0.15;
            const currentObstacleSpeed = baseSpeed * speedMultiplier;

            // Move obstacles & check collisions
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.y += currentObstacleSpeed;

                if (!invisibleActive) {
                    if (rectCollide(
                        {x: player.x, y: player.y, width: player.width, height: player.height},
                        {x: obs.x, y: obs.y, width: obs.width, height: obs.height}
                    )) {
                        gameOver();
                        return;
                    }
                }

                if (obs.y > canvas.height + 100) {
                    obstacles.splice(i, 1);
                    if (gameActive) {
                        score += 15;
                        updateScore();
                    }
                }
            }

            // Move power-ups & collect
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                p.y += currentObstacleSpeed * 0.9;

                if (rectCollide(
                    {x: player.x, y: player.y, width: player.width, height: player.height},
                    {x: p.x, y: p.y, width: p.width, height: p.height}
                )) {
                    if (p.type === 'boost') {
                        boostActive = true;
                        boostFramesLeft = BOOST_DURATION_FRAMES;
                        player.speed = player.baseSpeed * 2.5;
                    } else if (p.type === 'emmanuel') {
                        invisibleActive = true;
                        invisibleFramesLeft = INVISIBLE_DURATION_FRAMES;
                    }
                    powerUps.splice(i, 1);
                    continue;
                }

                if (p.y > canvas.height + 100) {
                    powerUps.splice(i, 1);
                }
            }

            // Spawn obstacles
            framesSinceLastObstacle++;
            if (framesSinceLastObstacle >= nextObstacleFrame && gameActive) {
                spawnObstacle();
                framesSinceLastObstacle = 0;
                nextObstacleFrame = randomSpawnDelay();
                score += 5;
                updateScore();
            }

            // Spawn power-ups based on real time
            if (now - lastBoostSpawn >= BOOST_SPAWN_INTERVAL) {
                spawnPowerUp('boost');
                lastBoostSpawn = now;
            }
            if (now - lastEmmanuelSpawn >= EMMANUEL_SPAWN_INTERVAL) {
                spawnPowerUp('emmanuel');
                lastEmmanuelSpawn = now;
            }

            // Update effect timers
            if (boostActive) {
                boostFramesLeft--;
                if (boostFramesLeft <= 0) {
                    boostActive = false;
                    player.speed = player.baseSpeed;
                }
            }
            if (invisibleActive) {
                invisibleFramesLeft--;
                if (invisibleFramesLeft <= 0) {
                    invisibleActive = false;
                }
            }

            // Small passive score
            if (gameActive && framesSinceLastObstacle % 6 === 0) {
                score += 1;
                updateScore();
            }

            updatePowerupDisplay();
        }

        // ---------- DRAWING ----------
        function drawRoad() {
            ctx.fillStyle = '#2d4d5e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#e0eef7';
            ctx.lineWidth = 5;
            ctx.setLineDash([25, 25]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();

            ctx.setLineDash([]);
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#f3a446';
            ctx.beginPath();
            ctx.moveTo(20, 0);
            ctx.lineTo(20, canvas.height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(canvas.width - 20, 0);
            ctx.lineTo(canvas.width - 20, canvas.height);
            ctx.stroke();

            ctx.fillStyle = '#9eb6b0';
            ctx.globalAlpha = 0.2;
            ctx.fillRect(0, (Date.now() * 0.05) % canvas.height, canvas.width, 8);
            ctx.globalAlpha = 1.0;
        }

        function drawPlayer() {
            if (invisibleActive) {
                ctx.globalAlpha = 0.4;
            }
            ctx.fillStyle = '#dc2626';
            ctx.shadowColor = '#ffb347';
            ctx.shadowBlur = 18;
            ctx.beginPath();
            ctx.roundRect(player.x, player.y, player.width, player.height, 12);
            ctx.fill();

            ctx.shadowBlur = 8;
            ctx.fillStyle = '#2b2b2b';
            ctx.beginPath();
            ctx.roundRect(player.x + 8, player.y + 8, player.width - 16, 18, 6);
            ctx.fill();

            ctx.fillStyle = '#f5e56b';
            ctx.shadowBlur = 15;
            ctx.fillRect(player.x + 5, player.y + player.height-20, 10, 10);
            ctx.fillRect(player.x + player.width-15, player.y + player.height-20, 10, 10);

            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.globalAlpha = 1.0;
        }

        function drawObstacles() {
            for (let obs of obstacles) {
                ctx.fillStyle = '#1f4a5c';
                ctx.shadowColor = '#70b8ff';
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.roundRect(obs.x, obs.y, obs.width, obs.height, 10);
                ctx.fill();

                ctx.fillStyle = '#abc9dd';
                ctx.shadowBlur = 6;
                ctx.fillRect(obs.x + 8, obs.y + 10, obs.width - 16, 18);

                ctx.fillStyle = '#e34a4a';
                ctx.fillRect(obs.x + 5, obs.y + obs.height-15, 8, 8);
                ctx.fillRect(obs.x + obs.width-13, obs.y + obs.height-15, 8, 8);
            }
            ctx.shadowBlur = 0;
        }

        function drawPowerUps() {
            for (let p of powerUps) {
                if (p.type === 'boost') {
                    ctx.fillStyle = '#FFD966';
                    ctx.shadowColor = '#FFA500';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.moveTo(p.x + p.width/2, p.y + 5);
                    ctx.lineTo(p.x + p.width-8, p.y + p.height/2);
                    ctx.lineTo(p.x + p.width/2+3, p.y + p.height/2);
                    ctx.lineTo(p.x + p.width/2-3, p.y + p.height-5);
                    ctx.lineTo(p.x + 8, p.y + p.height/2);
                    ctx.lineTo(p.x + p.width/2-5, p.y + p.height/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.font = 'bold 16px monospace';
                    ctx.fillStyle = '#000';
                    ctx.shadowBlur = 0;
                    ctx.fillText('B', p.x+12, p.y+28);
                } else if (p.type === 'emmanuel') {
                    ctx.fillStyle = '#6CA0DC';
                    ctx.shadowColor = '#1E90FF';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.ellipse(p.x + p.width/2, p.y + p.height/2, p.width/2, p.height/2.5, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.font = 'bold 18px monospace';
                    ctx.fillStyle = '#FFF';
                    ctx.shadowBlur = 8;
                    ctx.fillText('E', p.x+13, p.y+28);
                }
            }
            ctx.shadowBlur = 0;
        }

        function drawGameOver() {
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = '#0f1b24';
            ctx.fillRect(0, canvas.height/2-70, canvas.width, 110);
            ctx.globalAlpha = 1;
            ctx.font = 'bold 40px "Segoe UI", monospace';
            ctx.fillStyle = '#f3a446';
            ctx.shadowColor = '#b55a1e';
            ctx.shadowBlur = 12;
            ctx.fillText('‚õî CRASH', 90, canvas.height/2);
            ctx.font = '24px monospace';
            ctx.fillStyle = '#ffcd94';
            ctx.fillText('press DRIVE AGAIN', 120, canvas.height/2 + 45);
            ctx.shadowBlur = 0;
        }

        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.quadraticCurveTo(x + w, y, x + w, y + r);
            this.lineTo(x + w, y + h - r);
            this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            this.lineTo(x + r, y + h);
            this.quadraticCurveTo(x, y + h, x, y + h - r);
            this.lineTo(x, y + r);
            this.quadraticCurveTo(x, y, x + r, y);
            this.closePath();
            return this;
        };

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawRoad();
            drawObstacles();
            drawPowerUps();
            drawPlayer();

            if (!gameActive && obstacles.length > 0) {
                drawGameOver();
            } else if (!gameActive && obstacles.length === 0 && score === 0) {
                ctx.font = '28px "Segoe UI", sans-serif';
                ctx.fillStyle = '#ffe7b0';
                ctx.shadowBlur = 12;
                ctx.fillText('üö¶ PRESS START', 120, canvas.height/2);
                ctx.shadowBlur = 0;
            }

            ctx.font = 'bold 18px monospace';
            ctx.fillStyle = '#fef7d2';
            ctx.fillText('‚ö° x' + speedMultiplier.toFixed(2), 380, 40);
            if (invisibleActive) {
                ctx.fillStyle = '#a0dbff';
                ctx.fillText('üëª EMMANUEL ACTIVE', 20, 40);
            }
        }

        // ---------- GAME LOOP ----------
        function gameLoop(timestamp) {
            if (gameActive) {
                movePlayer();
                updateGame(timestamp);
            }
            draw();
            frameId = requestAnimationFrame(gameLoop);
        }

        // ---------- EVENT LISTENERS ----------
        window.addEventListener('keydown', (e) => {
            if (e.key.startsWith('Arrow')) {
                e.preventDefault();
                if (e.key in keys) keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key.startsWith('Arrow')) {
                e.preventDefault();
                if (e.key in keys) keys[e.key] = false;
            }
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            resetGame();
            if (!frameId) {
                frameId = requestAnimationFrame(gameLoop);
            }
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        canvas.addEventListener('touchstart', (e) => e.preventDefault());

        // initial reset (inactive until restart)
        resetGame();
        gameActive = false;
        obstacles = [];
        powerUps = [];
        player.x = (canvas.width / 2) - (CAR_WIDTH / 2);
        player.y = canvas.height - CAR_HEIGHT - 20;
        score = 0;
        updateScore();
        updatePowerupDisplay();

        if (!frameId) {
            frameId = requestAnimationFrame(gameLoop);
        }
    })();
</script>
</body>
</html>